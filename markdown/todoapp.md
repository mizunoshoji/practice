## 作業内容まとめ

JS で機能を実装する部分

- App クラスに mount メソッドを実装する
  - form 要素の submit イベントをリッスンする。イベントリスナーを定義する。
  - form 要素が submit イベントをリッスンしたときのデフォルトの動きをキャンセルする。
    - 指定された URL、指定がないなら現在の URL に form のデータを送信するが、このときページをリロードしてしまうから。
  - コンソールに入力値を出力する
- index.js 側で App インスタンスの mount メソッドを呼び出す

改めてデータを埋め込んだ HTML を作成して表示する方法を整理したい

- DOM を手続き的に組み立てる

- ある要素に HTML 要素を追加するのか HTML 文字列を追加するのか

この２つの違いははっきり区別して認識しておくべき。混同せず使いわける。

1. 既存要素の innerHTML プロパティに HTML 文字列を追加する
2. 既存要素の子要素に HMTL 要素を追加する

少し詳細にみるとこう

1. テンプレート文字列でデータを埋め込んだ HTML 文字列をつくる-->特殊文字エスケープ-->HTML 要素に変換-->HTML 要素を既存の要素に appedChiled などで追加する
2. テンプレート文字列でデータを埋め込んだ HTML 文字列をつくる-->特殊文字エスケープ-->エスケープされた HTML 文字列に変換-->HTML 文字列を既存の要素の innerHTML に追加する

> Todo リスト（#js-todo-list）というすでに存在する要素に対して要素を追加するには、HTML 文字列ではなく HTML 要素が必要になります。

また HMTL 文字列にはイベントリスナーを追加できない。HTML 要素なら addEventListener メソッドが利用できる。今回は要素に発生したイベントをリッスンする機能が必要になるので HTML 要素を用意する。

> HTML 文字列に対しては addEventListener でイベントをリッスンできません。 そのため、チェックボックスの状態が変わったことや削除ボタンが押されたことを知る必要がある Todo アプリでは HTML 要素が必要になります。

読むだけでは概念を理解できないのでわかってなくてもコードを読んで書いてみる。そのあとまた説明を読み返せばいい。理解の前提をつくってからでないと言葉だけでは理解できない。

- ドキュメンテーションコメントのパラメータの型は波括弧で囲む

```
@param {string}
```

- constructor()の引数にオブジェクトを渡すこともできる。インスタンス化するときにもオブジェクトを渡す。

コンストラクタ定義時

```
constructor({ title, completed })

```

インスタンス作成時

```
new クラス名({
  title: 'タイトル',
  completed: true
})
```

### 全体の流れ

中身の前に基本となる大枠をつくる。

エントリーポイント。index.html で JS モジュール index.js を読み込む。これは JavaScript のエントリーポイントとなる。index.js は src/App.js というモジュールをインポートする。

なぜこの構成か？が大事。複数のモジュールを連携させたい。連携させて使用するにはモジュールごとにスコープが異なっていると不都合である。別々の script 要素で JS モジュールを読み込むと各モジュールごとにスコープが作成されてしまい連携できない。そこで１つの script 要素でモジュール index.js を読み込み、スコープが異なる状態をさけてモジュール間の連携をしやすくする。

HTML と CSS でアプリケーションの画面を作成する。どこを HTML で定義してどこを JS で動的に作成するかを整理する。

直接 DOM を更新することの問題点

- 直接 DOM を更新すると DOM 上にしかデータがないことになる
- 任意のアイテムを更新するために、すべてのアイテムに識別情報を付与する必要がある、しかし HTML 要素に識別子となるデータを与えようとすると文字列しか与えられない、これは制限を発生させることになり、柔軟性がない。
- 入力となるイベントに対して表示の更新箇所が増えるほど、イベントリスナーの処理は複雑化する。ひとつの操作で複数の表示更新をしようとすると処理が複雑になる。

モデルを導入する

機能を、操作(イベント、入力)->モデル->表示で考える。MVC モデルみたいな感じ、少し違う気するけど。そうするとモデル->表示の部分でモデルで起きたイベントを表示がリッスンするということが必要になる。

画面要素をオブジェクトとして表現するためにクラスを使う。状態に関するデータはモデルであるクラスのインスタンスで保持する。HTML で文字列データを保持するのではなく JS のクラスでデータを保持すれば文字列以外のデータを保持できて柔軟である。

表示処理が複猿化する問題は、モデルの状態を参照してビューを組み立てて表示するやり方になる。DOM を直接書き換えたりしながら表示する処理は複雑になる、状態の保持や変更の処理はインスタンスをつかってやって、ビューがやることは少なくするイメージ。。。基本モデルからビューを作成するという処理になるので、ある操作に対して表示処理であちこち更新するような複雑化は抑えられる。

EventEmmtter クラスの定義。実行サンプルの方はわかるけどクラスのメソッドの処理内容になると理解できない。たぶん Map を理解できていないからだと思う。使い方どうだっけ？やっぱり本で一度読んだだけではまったく身につかない。

### 作業前のイメージ

画面要素として

- タスクを入力するフィールド
- タスクを追加するボタン
- タスクを表示するリスト
  - タスクごとの状態の表示
  - タスクごとの状態の変更
    - 更新
    - 削除

JS アプリでデータを管理する方法をイメージできない。配列使うのか...?ブラウザのストレージを使うのか...?

設計としては、追加、更新、削除処理をそれぞれモジュール化するとか？
タスクの状態を判断して、どの処理を呼び出すかという流れになるだろう

## このセクションのねらいは?

- データを取得して表示するだけでなくデータの状態を管理する機能を作成できるようにする
- Web アプリ作成のために必要な設計の考え方を身につける
- アプリの表示要素をコンポーネント単位に分割しメンテナンス性を向上させる
- イベント駆動の概念を理解する
- 直接 DOM を追加する手法のデメリット、問題点を理解する
  - DOM を直接更新しても状態が残らない、これは柔軟性がないということになる

## 疑問点

- 入力データをどこに送信して保持しておくのか
- DB がないのに Todo アイテムをどこでどうやって管理するか
- Todo アイテムの状態をどこでどうやって管理するか
- 表示するにもどこからアイテムを取得するのか
- 機能をどう分割してモジュール化するか、作業前にイメージできない
- 操作と更新が密結合になってしまい変更がしにくくなる問題とはどんな問題か
  - モデルとイベントがこの問題をどう解消するのか
- script 要素の type 属性で module を設定するとどうなるのか
- class の理解や実践的な使用に自信がないので調べたい
  - この例では class を名前付きでエクスポートする App.js モジュールを作成している
  - エクスポートされた App クラスを JavaScript のエントリーポイントである index.js でインポートし、new 演算子でインスタンス化、このとき App クラスのコンストラクタが実行されている。
- バンドラー bundler とはどういう役割のツールか
  - browserify はバンドラでたしかモジュールの依存関係を解決するとかだった気がする
- タグ関数って何？
- > template 要素は HTML5 で追加された、HTML 文字列の断片から HTML 要素を作成できる要素です。
- 状態に関するデータを HTML 要素に埋め込む場合文字列しか与えられないのは制限である、というのはいまいち実感としては理解できない。文字列しか付与できないのは不便ということなのだろう。
- ディスパッチの意味
  - 発送する、派遣する。IT 文脈では機能の呼び出しの意味。今回の文脈ではイベントが発生したら登録されたコールバック関数が呼び出す。ディスパッチとは発生と呼び出しがセットになったような概念と解釈できるのかも。
- emit の意味
  - 発する、吐く、放出する、(電波で)送る
- EventEmitter の意味
  - イベントを送るもの
- Map って何だっけ？
  - 連想配列を管理するためのオブジェクト、JS 組み込みオブジェクト。
  - どんなケースで利用するか、利用シーンは？
  - Map のメソッド
    - has()
    - set()
    - get()
    - `new Set()`は何をしている？set って何？
- addEventListener メソッド、map に直接 lisner をセットせず一回 Set()を実行してから変数 listenerSet に代入し、それに add()を使用して lintener を追加している。なぜ直接 listener を map にセットしないのか？
- constructor の中で super()を呼び出すと何をする？--->super メソッドは親クラスのコンストラクタの処理を呼び出す。呼び刺さずに子クラスで this を参照するとエラーになる。コンストラクターは親クラス->子クラスの順に実行する決まりになっている。

## 理解すべき前提

### モジュールスコープ

異なるモジュールスコープを持つモジュールが複数あるとき、あるモジュールが他のモジュールで宣言された変数を直接参照することができない。スコープが異なるので未定義エラーになる。

### 実行コンテキスト、Script と Module

### モジュールを使うときの注意点

- script 要素に type="module"を指定して実行コンテキストがモジュールになるようにする
- モジュールスコープがモジュールごとに作成されることを知っておく
- 名前つきエクスポートとデフォルトエクスポートの使い分けができるようにする
- import 宣言はモジュールのトップレベルでしか利用できない
- モジュール内では strict モードになる

### イベントのリッスン

- 対象にイベントが配信された時に実行するイベントリスナーを定義する
- https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener

## 参考リンク

- https://caniuse.com/

  - CanIuse は、デスクトップおよびモバイル Web ブラウザーでフロントエンド Web テクノロジーをサポートするための最新のブラウザーサポートテーブルを提供します。
