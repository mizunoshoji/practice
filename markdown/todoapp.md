## 作業内容まとめ

JS で機能を実装する部分

- App クラスに mount メソッドを実装する
  - form 要素の submit イベントをリッスンする。イベントリスナーを定義する。
  - form 要素が submit イベントをリッスンしたときのデフォルトの動きをキャンセルする。
    - 指定された URL、指定がないなら現在の URL に form のデータを送信するが、このときページをリロードしてしまうから。
  - コンソールに入力値を出力する
- index.js 側で App インスタンスの mount メソッドを呼び出す

改めてデータを埋め込んだ HTML を作成して表示する方法を整理したい

- DOM を手続き的に組み立てる

- ある要素に HTML 要素を追加するのか HTML 文字列を追加するのか

この２つの違いははっきり区別して認識しておくべき。混同せず使いわける。

1. 既存要素の innerHTML プロパティに HTML 文字列を追加する
2. 既存要素の子要素に HMTL 要素を追加する

少し詳細にみるとこう

1. テンプレート文字列でデータを埋め込んだ HTML 文字列をつくる-->特殊文字エスケープ-->HTML 要素に変換-->HTML 要素を既存の要素に appedChiled などで追加する
2. テンプレート文字列でデータを埋め込んだ HTML 文字列をつくる-->特殊文字エスケープ-->エスケープされた HTML 文字列に変換-->HTML 文字列を既存の要素の innerHTML に追加する

> Todo リスト（#js-todo-list）というすでに存在する要素に対して要素を追加するには、HTML 文字列ではなく HTML 要素が必要になります。

また HMTL 文字列にはイベントリスナーを追加できない。HTML 要素なら addEventListener メソッドが利用できる。今回は要素に発生したイベントをリッスンする機能が必要になるので HTML 要素を用意する。

> HTML 文字列に対しては addEventListener でイベントをリッスンできません。 そのため、チェックボックスの状態が変わったことや削除ボタンが押されたことを知る必要がある Todo アプリでは HTML 要素が必要になります。

読むだけでは概念を理解できないのでわかってなくてもコードを読んで書いてみる。そのあとまた説明を読み返せばいい。理解の前提をつくってからでないと言葉だけでは理解できない。

- ドキュメンテーションコメントのパラメータの型は波括弧で囲む

```
@param {string}
```

- constructor()の引数にオブジェクトを渡すこともできる。インスタンス化するときにもオブジェクトを渡す。

コンストラクタ定義時

```
constructor({ title, completed })

```

インスタンス作成時

```
new クラス名({
  title: 'タイトル',
  completed: true
})
```

- import するときに from の後のパスは`.js`拡張子を省略しない。自動補完に頼りすぎると見落として読み込みエラーになる

- 仮引数と実引数は同じ型であるべき。例えば object を受け取る関数には object を渡す。変な不具合を避けるため。エラーがでないとかある。

定義

```
deleteTodo({ id }) {
  // 省略
}
```

呼び出し

```
this.todoListModel.deleteTodo({
  id: item.id,
});
```

App.js にはいくつかの役割を持つコードがまとめて書かれている。

- モデルの初期化処理
- HTML 要素とモデルの間で発生するイベントの管理
  - HTML 要素のイベント発生でモデルを操作
  - モデルの変更イベントで HTML を更新
- HTML 要素の作成

このままだと App.js が肥大化しメンテナンス性が悪くなる。そこで HTML 要素の作成処理を別のクラスとして切り出す、という手がある。App.js はイベント管理の役割が中心になるようにリファクタリングを行う。

まず App.js がどうなっているとわかりやすいのかを明確にする。アプリの機能が、追加、更新、削除であることが見てわかるようなコードにしたいという方向。これは Laravel のコントローラーになんとなく似ている。App クラスの中はこういう感じ。

```
constructor() {
  // モデルのインスタンス化
}

handleAdd() {
  this.todoListModel.addTodo() // 追加処理
}

handleUpdate() {
  this.todoListModel.updateTodo() // 更新処理
}

handleDelete() {
  this.todoListModel.deleteTodo() // 削除処理
}

```

App クラスではリスナー関数を handle メソッドとして定義し直す。イベント発生したら handle メソッドを呼び出す。こうするとたしかに App が何をするのかがコードを見ればわかるような構成になる。

HTML Element | Event | EventListener
checkbox --> change --> TodoListModel.updateTodo()を実行 モデルのメソッド
checkbox --> change --> onUpdateTodo()を実行 コールバック関数

View コンポーネント

- 引数に対応するモデルを受け取る
- 引数に View で実行したいイベントリスナー(コールバック関数)を受け取る
- テンプレート HTML 文字列を定義する
- View コンポーネントでイベントが発生する要素にイベントリスナーを登録する
  - リスナー関数(コールバック関数)を実行するだけになっている、View に具体的な処理内容は書かれていない
    - View クラス内では具体的な処理を書かず、外側にそれを書きたいという意図がある
  - リスナー関数(コールバック関数)は View コンポーネントの外から引数として受け取っている
  - 発生するイベントとリスナー関数(コールバック関数)の呼び出しだけが対応づけられている状態にみえる

引数に渡されるコールバック関数の定義がどこで行われるのかが重要、どこ？--->それは TodoItemView の createElement メソッドに実引数が渡され呼び出される箇所である--->それはどこ？--->

**追加のタスク**

### 空のアイテムが作成されないようにバリデーションを実装する

バリデーションをどのように実装するのがいいのか？自分のなんとなくの感覚だけだとこうなる。「App.js 内の mount メソッドで登録されている submit イベントのリスナー関数内で handleAdd メソッドを実行されている、ならこの直前で inputElement.value を判定して空ならエラーを出して空ではないなら追加実行でできる、つまり App の handleAdd メソッドの直前でチェックすればいい。」しかしこのやり方は良くない、やっぱり設計のルールとかパターンがわかってないから良くない考え方で手をつけてしまいがちだ...。

考え方の入り口を修正すべき。input の value をチェックするのではなく、TodoList に TodoItem を追加する前に、タイトルが空かを判定する。表示はモデルの状態に基づいているのだからモデルに追加されないようにすればいい、ということになる。だからモデルクラスに処理を実装する。

addTotdo メソッド自体は実行されているがその中でチェックしている

### アプリケーションのライフサイクル イベント登録と解除 unmount メソッドの実装

イベントは登録しっぱなしだとメモリリークにつながる？

- メモリリーク
  - 何らかの原因でデータがメモリに残ってしまうこと
  - ブラウザが落ちたりクラッシュしたりする原因になる
  - ブラウザで JS が実行されるときはメモリが定期的にクリアされている
  - ガベージコレクションという仕組みがある
  - https://logmi.jp/tech/articles/322067 詳しいが...むずい

クライアントサイドだけの JS でメモリリークとは具体的にどういうこと？仕組み上何が起きている？

メモリリークの調査はどうやるのか？

開発者ツールの Memory パネルでメモリの使用状況に関する情報を見ることができる。

- メモリ使用状況のスナップショットを比較する
- グローバルのメモリ消費をみる
- 何をどれくらいメモリに割り当てているか
- 割り当てが多いのに解放されていないメモリがないか？これはメモリリークがあるかどうか？ということ。

質問

- どんなオブジェクトがメモリを使用しているか-->Constructor をみる
- 各オブジェクト自体がどれくらいメモリを使用しているか-->Shallow Size をみる
- あるオブジェクトに依存して存在している他のオブジェクトも含めた使用サイズをみたい-->Retained Size をみる
- あるオブジェクトが存在しなくなることで合計でどれくらいメモリが解放されるか-->Retained Size をみる

Chrome DevTools の使い方が紹介されている https://knowledge.sakura.ad.jp/28024/

Web アプリケーションのライフサイクル

ページのロード-->App のマウント-->ページのアンロード-->App のアンマウント

ページのアンロードって何だ？--->unload イベントが発生するとブラウザによってメモリがクリアされページは終了状態(Terminated
)になる。ページが Hidden State のときに unload イベントが発生する流れになることがある。Hidden state とはページが表示されないがフリーズはしていない状態である。

mount メソッドは「DOM とアプリの紐付けをする関数」と解説されている。やっているのはイベントリスナーの登録

unmount メソッドがなぜ必要なのか？わからない。イベント登録を解除しなければならない？

- https://developers.google.com/web/updates/2018/07/page-lifecycle-api。Web ページのライフサイクル、イベントについての図。あと unload イベントは信頼できないとも書かれている。

- ブラウザの動作の仕組み。https://developer.mozilla.org/ja/docs/Web/Performance/How_browsers_work

わざわざ unload イベントリスナーで app の unmount がなぜ必要なのかがわからない。

this の参照先という面倒なテーマがある
https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/this

load と unload、イベントの解除

結局「なんで、unload イベントが発生したタイミングでイベントリスナーを解除する必要があるか」がわからない。「メモリリークが発生する原因になるかもしれないから」と言われても、言葉だけでは結局わからない。

### 全体の流れ

中身の前に基本となる大枠をつくる。

エントリーポイント。index.html で JS モジュール index.js を読み込む。これは JavaScript のエントリーポイントとなる。index.js は src/App.js というモジュールをインポートする。

なぜこの構成か？が大事。複数のモジュールを連携させたい。連携させて使用するにはモジュールごとにスコープが異なっていると不都合である。別々の script 要素で JS モジュールを読み込むと各モジュールごとにスコープが作成されてしまい連携できない。そこで１つの script 要素でモジュール index.js を読み込み、スコープが異なる状態をさけてモジュール間の連携をしやすくする。

HTML と CSS でアプリケーションの画面を作成する。どこを HTML で定義してどこを JS で動的に作成するかを整理する。

直接 DOM を更新することの問題点

- 直接 DOM を更新すると DOM 上にしかデータがないことになる
- 任意のアイテムを更新するために、すべてのアイテムに識別情報を付与する必要がある、しかし HTML 要素に識別子となるデータを与えようとすると文字列しか与えられない、これは制限を発生させることになり、柔軟性がない。
- 入力となるイベントに対して表示の更新箇所が増えるほど、イベントリスナーの処理は複雑化する。ひとつの操作で複数の表示更新をしようとすると処理が複雑になる。

モデルを導入する

機能を、操作(イベント、入力)->モデル->表示で考える。MVC モデルみたいな感じ、少し違う気するけど。そうするとモデル->表示の部分でモデルで起きたイベントを表示がリッスンするということが必要になる。

画面要素をオブジェクトとして表現するためにクラスを使う。状態に関するデータはモデルであるクラスのインスタンスで保持する。HTML で文字列データを保持するのではなく JS のクラスでデータを保持すれば文字列以外のデータを保持できて柔軟である。

表示処理が複猿化する問題は、モデルの状態を参照してビューを組み立てて表示するやり方になる。DOM を直接書き換えたりしながら表示する処理は複雑になる、状態の保持や変更の処理はインスタンスをつかってやって、ビューがやることは少なくするイメージ。。。基本モデルからビューを作成するという処理になるので、ある操作に対して表示処理であちこち更新するような複雑化は抑えられる。

EventEmmtter クラスの定義。実行サンプルの方はわかるけどクラスのメソッドの処理内容になると理解できない。たぶん Map を理解できていないからだと思う。使い方どうだっけ？やっぱり本で一度読んだだけではまったく身につかない。

### 作業前のイメージ

画面要素として

- タスクを入力するフィールド
- タスクを追加するボタン
- タスクを表示するリスト
  - タスクごとの状態の表示
  - タスクごとの状態の変更
    - 更新
    - 削除

JS アプリでデータを管理する方法をイメージできない。配列使うのか...?ブラウザのストレージを使うのか...?

設計としては、追加、更新、削除処理をそれぞれモジュール化するとか？
タスクの状態を判断して、どの処理を呼び出すかという流れになるだろう

## このセクションのねらいは?

- データを取得して表示するだけでなくデータの状態を管理する機能を作成できるようにする
- Web アプリ作成のために必要な設計の考え方を身につける
- アプリの表示要素をコンポーネント単位に分割しメンテナンス性を向上させる
- イベント駆動の概念を理解する
- 直接 DOM を追加する手法のデメリット、問題点を理解する
  - DOM を直接更新しても状態が残らない、これは柔軟性がないということになる
- モデルを導入した設計、状態管理をモデルで実装する、モデルとビューの分離
- 継続的に開発するためのリファクタリング

## 疑問点

- 入力データをどこに送信して保持しておくのか
- DB がないのに Todo アイテムをどこでどうやって管理するか
- Todo アイテムの状態をどこでどうやって管理するか
- 表示するにもどこからアイテムを取得するのか
- 機能をどう分割してモジュール化するか、作業前にイメージできない
- 操作と更新が密結合になってしまい変更がしにくくなる問題とはどんな問題か
  - モデルとイベントがこの問題をどう解消するのか
- script 要素の type 属性で module を設定するとどうなるのか
- class の理解や実践的な使用に自信がないので調べたい
  - この例では class を名前付きでエクスポートする App.js モジュールを作成している
  - エクスポートされた App クラスを JavaScript のエントリーポイントである index.js でインポートし、new 演算子でインスタンス化、このとき App クラスのコンストラクタが実行されている。
- バンドラー bundler とはどういう役割のツールか
  - browserify はバンドラでたしかモジュールの依存関係を解決するとかだった気がする
- タグ関数って何？
- > template 要素は HTML5 で追加された、HTML 文字列の断片から HTML 要素を作成できる要素です。
- 状態に関するデータを HTML 要素に埋め込む場合文字列しか与えられないのは制限である、というのはいまいち実感としては理解できない。文字列しか付与できないのは不便ということなのだろう。
- ディスパッチの意味
  - 発送する、派遣する。IT 文脈では機能の呼び出しの意味。今回の文脈ではイベントが発生したら登録されたコールバック関数が呼び出す。ディスパッチとは発生と呼び出しがセットになったような概念と解釈できるのかも。
- emit の意味
  - 発する、吐く、放出する、(電波で)送る
- EventEmitter の意味
  - イベントを送るもの
- Map って何だっけ？
  - 連想配列を管理するためのオブジェクト、JS 組み込みオブジェクト。
  - どんなケースで利用するか、利用シーンは？
  - Map のメソッド
    - has()
    - set()
    - get()
    - `new Set()`は何をしている？set って何？
- addEventListener メソッド、map に直接 lisner をセットせず一回 Set()を実行してから変数 listenerSet に代入し、それに add()を使用して lintener を追加している。なぜ直接 listener を map にセットしないのか？
- constructor の中で super()を呼び出すと何をする？--->super メソッドは親クラスのコンストラクタの処理を呼び出す。呼び刺さずに子クラスで this を参照するとエラーになる。コンストラクターは親クラス->子クラスの順に実行する決まりになっている。

- これで<ul>が作成される？半角スペース何？

```
element`<ul />`
```

## 理解すべき前提

### モジュールスコープ

異なるモジュールスコープを持つモジュールが複数あるとき、あるモジュールが他のモジュールで宣言された変数を直接参照することができない。スコープが異なるので未定義エラーになる。

### 実行コンテキスト、Script と Module

### モジュールを使うときの注意点

- script 要素に type="module"を指定して実行コンテキストがモジュールになるようにする
- モジュールスコープがモジュールごとに作成されることを知っておく
- 名前つきエクスポートとデフォルトエクスポートの使い分けができるようにする
- import 宣言はモジュールのトップレベルでしか利用できない
- モジュール内では strict モードになる

### イベントのリッスン

- 対象にイベントが配信された時に実行するイベントリスナーを定義する
- https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener

## 参考リンク

- https://caniuse.com/

  - CanIuse は、デスクトップおよびモバイル Web ブラウザーでフロントエンド Web テクノロジーをサポートするための最新のブラウザーサポートテーブルを提供します。
